import os
import json
import pandas as pd

from config.config import *
from utils import *
from excel_report_handler import ExcelReportHandler
from open_cve_api import OpenCVEAPI


class CVEReport:
    """
    A class to handle the CVE report generation process.
    """

    def __init__(self):
        self.vuln_data_path = VULN_DATA_PATH
        self.report_directory = REPORTS_DIR
        self.cve_details_path = CVE_DETAILS_PATH
        self.cve_report_path = CVE_REPORTS_PATH
        LOGGER.info("Initializing CVEReport")
        self.vuln_data = self.read_json(self.vuln_data_path)
        self.excel_formatter = ExcelReportHandler(self.cve_report_path)
        self.open_cve_client = OpenCVEAPI()

    def read_json(self, file_path):
        """
        Read a JSON file and return its content.
        """
        if not os.path.isfile(file_path):
            LOGGER.error(f"The file '{file_path}' does not exist.")
            raise FileNotFoundError(f"The file '{file_path}' does not exist.")

        LOGGER.info(f"Opening file '{file_path}'")
        with open(file_path, "r") as f:
            return json.load(f)

    def parse_to_csv(self, chunk_size=CHUNK_SIZE):
        # remove csv if exist
        if os.path.exists(self.cve_details_path):
            os.remove(self.cve_details_path)

        chunk_size = min(len(self.vuln_data), chunk_size)

        parse_data = {
            BASE_IMAGE: [],
            IMAGE_NAME: [],
            PRODUCT: [],
            CVE_ID: [],
            CVE_SEVERITY: [],
            FIX_VERSION: [],
        }
        LOGGER.info("Parsing data to CSV")

        is_first_write = True

        # extract data from json to csv
        for index, vuln in enumerate(self.vuln_data):
            base_image, image_name = vuln["image_info"]["name"].split(":")
            product = vuln["product"]["name"]
            cve_id = vuln["vulnerability"]["id"]
            cve_severity = vuln["vulnerability"]["severity"]
            fix_version = vuln.get("fix", {}).get("fix", "")

            parse_data[BASE_IMAGE].append(base_image)
            parse_data[IMAGE_NAME].append(image_name)
            parse_data[PRODUCT].append(product)
            parse_data[CVE_ID].append(cve_id)
            parse_data[CVE_SEVERITY].append(cve_severity)
            parse_data[FIX_VERSION].append(fix_version)

            # Check if it's time to save this chunk
            try:
                if (index + 1) % chunk_size == 0 or (index + 1) == len(self.vuln_data):
                    df = pd.DataFrame(parse_data)
                    df.to_csv(
                        self.cve_details_path,
                        mode="a",
                        header=is_first_write,
                        index=False,
                    )
                    LOGGER.info(
                        f"Written total {index + 1} records to '{self.cve_details_path}'"
                    )
                    # Clear for the next chunk
                    parse_data = {key: [] for key in parse_data}
                    is_first_write = False
            except Exception as e:
                LOGGER.exception(
                    f"Failed to save chunk #{(index + 1)//chunk_size} with the error: \n{e}"
                )

        LOGGER.info("Parsing is completed")

    def analyze_vulnerabilities(self, cve_details_df):
        total_vuln = len(cve_details_df)
        unique_vuln = cve_details_df[CVE_ID].nunique()
        vuln_by_base = vulnerabilities_by_BaseImage(cve_details_df)
        vuln_by_image_severity = (
            cve_details_df.drop_duplicates(subset=[IMAGE_NAME, CVE_ID])
            .groupby([IMAGE_NAME, CVE_SEVERITY])
            .size()
            .unstack(fill_value=0)
            .sort_values(by=IMAGE_NAME)
        )
        products_fix_versions = (
            cve_details_df.groupby(PRODUCT)[FIX_VERSION]
            .apply(remove_duplicate_fix_versions)
            .sort_index(ascending=False)
        )
        vuln_by_product_base = sort_products_by_vulnerability_counts(cve_details_df)
        cve_desc = self.open_cve_client.get_cve_info(cve_details_df)
        priority_scores = calculate_priority_scores(vuln_by_image_severity)

        result = {
            TOTAL_VULN: total_vuln,
            UNIQUE_VULN: unique_vuln,
            VULN_BY_BASE: vuln_by_base,
            VULN_BY_IMAGE_SEVERITY: vuln_by_image_severity,
            PRODUCTS_FIX_VERSIONS: products_fix_versions,
            VULN_BY_PRODUCT_BASE: vuln_by_product_base,
            PRIORITY_SCORE: priority_scores,
            CVE_DESC: cve_desc,
        }
        return result

    def export_report(self):
        LOGGER.info("Exporting report")
        cve_details_df = pd.read_csv(self.cve_details_path)

        # Analyze the vulnerabilities data
        analysis_results = self.analyze_vulnerabilities(cve_details_df)

        # Update dataframes columns
        analysis_results = update_dataframes(analysis_results)
        try:
            self.excel_formatter.report_to_excel(analysis_results)
        except Exception as e:
            LOGGER.exception(f"Failed to save report to CSV file with the error: \n{e}")

        LOGGER.info("Exporting report completed")


if __name__ == "__main__":
    cve_report = CVEReport()
    cve_report.parse_to_csv()
    cve_report.export_report()
